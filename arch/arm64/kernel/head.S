/* SPDX-License-Identifier: GPL-2.0-only */
/*
 * Low-level CPU initialisation
 * Based on arch/arm/kernel/head.S
 *
 * Copyright (C) 1994-2002 Russell King
 * Copyright (C) 2003-2012 ARM Ltd.
 * Authors:	Catalin Marinas <catalin.marinas@arm.com>
 *		Will Deacon <will.deacon@arm.com>
 */

#include <linux/linkage.h>
#include <linux/init.h>
#include <linux/pgtable.h>

#include <asm/asm_pointer_auth.h>
#include <asm/assembler.h>
#include <asm/boot.h>
#include <asm/bug.h>
#include <asm/ptrace.h>
#include <asm/asm-offsets.h>
#include <asm/cache.h>
#include <asm/cputype.h>
#include <asm/el2_setup.h>
#include <asm/elf.h>
#include <asm/image.h>
#include <asm/kernel-pgtable.h>
#include <asm/kvm_arm.h>
#include <asm/memory.h>
#include <asm/pgtable-hwdef.h>
#include <asm/page.h>
#include <asm/scs.h>
#include <asm/smp.h>
#include <asm/sysreg.h>
#include <asm/thread_info.h>
#include <asm/virt.h>

#include "efi-header.S"

/* IAMROOT:
KERNEL_START --> 커널 시작 가상 주소(_text)
arch/arm64/include/asm/memory.h:64
#define KERNEL_START		_text
 */
#define __PHYS_OFFSET	KERNEL_START

#if (PAGE_OFFSET & 0x1fffff) != 0
#error PAGE_OFFSET must be at least 2MB aligned
#endif

/* IAMROOT:
Documentation/arm64/booting.rst 참고
 */
/*
 * Kernel startup entry point.
 * ---------------------------
 *
 * The requirements are:
 *   MMU = off, D-cache = off, I-cache = on or off,
 *   x0 = physical address to the FDT blob.
 *
 * This code is mostly position independent so you call this at
 * __pa(PAGE_OFFSET).
 *
 * Note that the callee-saved registers are used for storing variables
 * that are useful before the MMU is enabled. The allocations are described
 * in the entry routines.
 */
/* IAMROOT: 
[include/linux/init.h:95]
#define __HEAD		.section	".head.text","ax"
[arch/arm64/kernel/vmlinux.lds.S:155]
SECTIONS
{
	. = KIMAGE_VADDR;
	.head.text : {
		_text = .;
		HEAD_TEXT
	}
[arch/arm64/include/asm/memory.h:46]
#define KIMAGE_VADDR		(MODULES_END)
#define KIMAGE_VADDR		(MODULES_END)
#define MODULES_END		(MODULES_VADDR + MODULES_VSIZE)
#define MODULES_VADDR		(_PAGE_END(VA_BITS_MIN))
 */
	__HEAD
	/*
	 * DO NOT MODIFY. Image header expected by Linux boot-loaders.
	 */
	efi_signature_nop			// special NOP to identity as PE/COFF executable
	b	primary_entry			// branch to kernel start, magic
	.quad	0				// Image load offset from start of RAM, little-endian
	le64sym	_kernel_size_le			// Effective size of kernel image, little-endian
	le64sym	_kernel_flags_le		// Informative flags, little-endian
	.quad	0				// reserved
	.quad	0				// reserved
	.quad	0				// reserved
	.ascii	ARM64_IMAGE_MAGIC		// Magic number
	.long	.Lpe_header_offset		// Offset to the PE header.

	__EFI_PE_HEADER
/* IAMROOT: 
[include/linux/init.h:96]
#define __INIT		.section	".init.text","ax"
[include/asm-generic/vmlinux.lds.h:1145]
#define INIT_TEXT_SECTION(inittext_align)				\
	. = ALIGN(inittext_align);					\
	.init.text : AT(ADDR(.init.text) - LOAD_OFFSET) {		\
		_sinittext = .;						\
		INIT_TEXT						\
		_einittext = .;						\
	}
[include/asm-generic/vmlinux.lds.h:725]
#define INIT_TEXT							\
	*(.init.text .init.text.*)					\
	*(.text.startup)						\
	MEM_DISCARD(init.text*)
 */
	__INIT

	/*
	 * The following callee saved general purpose registers are used on the
	 * primary lowlevel boot path:
	 *
	 *  Register   Scope                      Purpose
	 *  x21        primary_entry() .. start_kernel()        FDT pointer passed at boot in x0
	 *  x23        primary_entry() .. start_kernel()        physical misalignment/KASLR offset
	 *  x28        __create_page_tables()                   callee preserved temp register
	 *  x19/x20    __primary_switch()                       callee preserved temp registers
	 *  x24        __primary_switch() .. relocate_kernel()  current RELR displacement
	 */
/* IAMROOT:
Documentation/asm-annotations.rst 참고
include/linux/linkage.h:282
#define SYM_CODE_START(name)				\
	SYM_START(name, SYM_L_GLOBAL, SYM_A_ALIGN)
#define SYM_L_GLOBAL(name)			.globl name
#define SYM_A_ALIGN				ALIGN
#define ALIGN __ALIGN
#define __ALIGN		.align 4,0x90
#define ASM_NL		 ;
#define SYM_START(name, linkage, align...)		\
	SYM_ENTRY(name, linkage, align)
#define SYM_ENTRY(name, linkage, align...)		\
	linkage(name) ASM_NL				\
	align ASM_NL					\
	name:
===>
.globl primary_entry;
.align 4,0x90;
primary_entry:
*/
SYM_CODE_START(primary_entry)
	bl	preserve_boot_args
	bl	init_kernel_el			// w0=cpu_boot_mode
	adrp	x23, __PHYS_OFFSET
	and	x23, x23, MIN_KIMG_ALIGN - 1	// KASLR offset, defaults to 0
	bl	set_cpu_boot_mode_flag
	bl	__create_page_tables
	/*
	 * The following calls CPU setup code, see arch/arm64/mm/proc.S for
	 * details.
	 * On return, the CPU will be ready for the MMU to be turned on and
	 * the TCR will have been set.
	 */
	bl	__cpu_setup			// initialise processor
	b	__primary_switch
SYM_CODE_END(primary_entry)

/*
 * Preserve the arguments passed by the bootloader in x0 .. x3
 */
/* IAMROOT: Documentation/arm64/booting.rst:159
- Primary CPU general-purpose register settings:
    - x0 = physical address of device tree blob (dtb) in system RAM.
    - x1 = 0 (reserved for future use)
    - x2 = 0 (reserved for future use)
    - x3 = 0 (reserved for future use)
- Secondary CPU general-purpose register settings
	- x0 = 0 (reserved for future use)
	- x1 = 0 (reserved for future use)
	- x2 = 0 (reserved for future use)
	- x3 = 0 (reserved for future use)
*/
SYM_CODE_START_LOCAL(preserve_boot_args)
	mov	x21, x0				// x21=FDT

/* IAMROOT: arch/arm64/include/asm/assembler.h:192
 * Pseudo-ops for PC-relative adr/ldr/str <reg>, <symbol> where
 * <symbol> is within the range +/- 4 GB of the PC.
x0 = &boot_args[0]
 */
	adr_l	x0, boot_args			// record the contents of
/* IAMROOT:
boot_args[0] = x21
boot_args[1] = x1
boot_args[2] = x2
boot_args[3] = x3
 */
	stp	x21, x1, [x0]			// x0 .. x3 at kernel entry
	stp	x2, x3, [x0, #16]

/* IAMROOT:
dcache_inval_poc 호출 전 모든 read & write 완료하도록
 */
	dmb	sy				// needed before dc ivac with
						// MMU off
/* IAMROOT:
x0 = &boot_args[0]
x1 = x0 + 32
dcache_inval_poc(x0, x1)
 */
	add	x1, x0, #0x20			// 4 x 8 bytes
	b	dcache_inval_poc		// tail call
SYM_CODE_END(preserve_boot_args)

/*
 * Macro to create a table entry to the next page.
 *
 *	tbl:	page table address            == idmap_pg_dir
 *	virt:	virtual address               == __idmap_text_start
 *	shift:	#imm page table shift         == 39
 *	ptrs:	#imm pointers per table page  == 2^(9) = 512
 *
 * Preserves:	virt
 * Corrupts:	ptrs, tmp1, tmp2
 * Returns:	tbl -> next level table page address
 */
/* IAMROOT:
create_table 매크로는 다음 페이지를 가리키는 하나의 엔트리를 생성해, 페이지 테이블에 해당하는 인덱스 위치에 쓴다
 */
	.macro	create_table_entry, tbl, virt, shift, ptrs, tmp1, tmp2
	add	\tmp1, \tbl, #PAGE_SIZE         // tmp1 = idmap_pg_dir + 4K
	phys_to_pte \tmp2, \tmp1            // tmp2 = tmp1 => next pg tbl address
	orr	\tmp2, \tmp2, #PMD_TYPE_TABLE	// address of next table and entry type, PMD_TYPE_TABLE 11(2)
	lsr	\tmp1, \virt, #\shift           //  tmp1 = __idmap_text_start  (right shift) 39, __idmap_text_start의 39 비트 이상 주소 => 인덱스?
	sub	\ptrs, \ptrs, #1                // ptrs (EXTRA_PTRS) = ptrs(EXTRA_PTRS)  - 1  =>   EXTRA_PTRS=512,  512 -1
	and	\tmp1, \tmp1, \ptrs		// table index, __idmap_text_start의 39 비트 이상 주소 와 511를 비트 and    => tmp1은 인덱스값
	str	\tmp2, [\tbl, \tmp1, lsl #3]    // tmp2 => [idmap_pg_dir + 바로 위에서 계산된 index , lsl 3]  tmp2는  next pg tbl address + 비트 or 11(2)
	add	\tbl, \tbl, #PAGE_SIZE		// next level table page
	.endm

/*
 * Macro to populate page table entries, these entries can be pointers to the next level
 * or last level entries pointing to physical memory.
 *
 *	tbl:	page table address
 *	rtbl:	pointer to page table or physical memory
 *	index:	start index to write
 *	eindex:	end index to write - [index, eindex] written to
 *	flags:	flags for pagetable entry to or in
 *	inc:	increment to rtbl between each entry
 *	tmp1:	temporary variable
 *
 * Preserves:	tbl, eindex, flags, inc
 * Corrupts:	index, tmp1
 * Returns:	rtbl
 */
/* IAMROOT:
 * - compute_indices에서 구해온 index를 가지고,
 * 해당 table entry에 해당하는 물리주소(rtbl)의 속성을 더하고 각 table entry에 mapping하는
 * 역할을 수행한다.
 */
	.macro populate_entries, tbl, rtbl, index, eindex, flags, inc, tmp1
.Lpe\@:	phys_to_pte \tmp1, \rtbl
	orr	\tmp1, \tmp1, \flags	// tmp1 = table entry
	str	\tmp1, [\tbl, \index, lsl #3]
	add	\rtbl, \rtbl, \inc	// rtbl = pa next level
	add	\index, \index, #1
	cmp	\index, \eindex
	b.ls	.Lpe\@  //.L <== Local 범위, \@ <== 호출 시 마다 +1 숫자 부여하여 구분하도록
	.endm

/*
 * Compute indices of table entries from virtual address range. If multiple entries
 * were needed in the previous page table level then the next page table level is assumed
 * to be composed of multiple pages. (This effectively scales the end index).
 *
 *	vstart:	virtual address of start of range
 *	vend:	virtual address of end of range - we map [vstart, vend]
 *	shift:	shift used to transform virtual address into index
 *	ptrs:	number of entries in page table
 *	istart:	index in table corresponding to vstart
 *	iend:	index in table corresponding to vend
 *	count:	On entry: how many extra entries were required in previous level, scales
 *			  our end index.
 *		On exit: returns how many extra entries required for next page table level
 *
 * Preserves:	vstart, vend, shift, ptrs
 * Returns:	istart, iend, count
 */
/* IAMROOT:
 *   - PGD table : entry 값 (count + 1) 이 1이 나옴.
 *       istart = (vstart >> 39) & (0x1ff)
 *       iend = (vend >> 39) & (0x1ff)
 *       count = iend - istart = 0
 *       table 크기가 작기때문에 보통 entry 값이 한개가 나옴.
 *
 *   - PUD table : shift 39값을 30으로 치환해서 계산. 역시 1개의 entry만 나옴
 *   - PMD table : shift를 21값으로 치환해서 계산. 2MB 범위 이므로 여러개가 나올수있음.
 *
 *   그래서 해당 table의 istart, iend, count의 계산 결과 값이 나온다.
 */
	.macro compute_indices, vstart, vend, shift, ptrs, istart, iend, count
	lsr	\iend, \vend, \shift
	mov	\istart, \ptrs
	sub	\istart, \istart, #1
	and	\iend, \iend, \istart	// iend = (vend >> shift) & (ptrs - 1)
	mov	\istart, \ptrs
	mul	\istart, \istart, \count
	add	\iend, \iend, \istart	// iend += count * ptrs
					// our entries span multiple tables

	lsr	\istart, \vstart, \shift
	mov	\count, \ptrs
	sub	\count, \count, #1
	and	\istart, \istart, \count

	sub	\count, \iend, \istart
	.endm

/*
 * Map memory for specified virtual address range. Each level of page table needed supports
 * multiple entries. If a level requires n entries the next page table level is assumed to be
 * formed from n pages.
 *
 *	tbl(x0):	location of page table == idmap_pg_dir
 *	rtbl(x1):	address to be used for first level page table entry (typically tbl + PAGE_SIZE)
 *	vstart(x3):	virtual address of start of range == __idmap_text_start
 *	vend(x6):	virtual address of end of range - we map [vstart, vend - 1] == __idmap_text_end
 *	flags(x7):	flags to use to map last level entries == SWAPPER_MM_MMUFLAGS
 *	phys(x3):	physical address corresponding to vstart - physical memory is contiguous
 *	pgds(x4):	the number of pgd entries == idmap_ptrs_per_pgd
 *
 * Temporaries:	istart, iend, tmp, count, sv - these need to be different registers
 * Preserves:	vstart, flags
 * Corrupts:	tbl, rtbl, vend, istart, iend, tmp, count, sv
 */
/* IAMROOT:
 * - 가상메모리 범위의 page table level의 entry를 초기화 한다.
 *   현재 SWAPPER_PGTABLE_LEVELS은 3이므로 PGD, PMD, PTE만을 초기화 하게 된다.
 *   실제로는 PGD, PUD, PMD이지만 code의 통일성을 위해 PGD, PMD, PTE로 되어있다.
 *
 *   code(실제) | shift
 *   ---------------
 *   PGD(PGD)   : 39
 *   PMD(PUD)   : 30
 *   PTE(PMD)   : 21
 *
 *   bic : bic A, B, #C ==> A = (B & ~C)
 * https://developer.arm.com/documentation/101811/0102/Translation-granule
 */
	.macro map_memory, tbl, rtbl, vstart, vend, flags, phys, pgds, istart, iend, tmp, count, sv
	sub \vend, \vend, #1
	add \rtbl, \tbl, #PAGE_SIZE
	mov \sv, \rtbl
	mov \count, #0
	compute_indices \vstart, \vend, #PGDIR_SHIFT, \pgds, \istart, \iend, \count
	populate_entries \tbl, \rtbl, \istart, \iend, #PMD_TYPE_TABLE, #PAGE_SIZE, \tmp
	mov \tbl, \sv
	mov \sv, \rtbl

#if SWAPPER_PGTABLE_LEVELS > 3
	compute_indices \vstart, \vend, #PUD_SHIFT, #PTRS_PER_PUD, \istart, \iend, \count
	populate_entries \tbl, \rtbl, \istart, \iend, #PMD_TYPE_TABLE, #PAGE_SIZE, \tmp
	mov \tbl, \sv
	mov \sv, \rtbl
#endif

#if SWAPPER_PGTABLE_LEVELS > 2
	compute_indices \vstart, \vend, #SWAPPER_TABLE_SHIFT, #PTRS_PER_PMD, \istart, \iend, \count
	populate_entries \tbl, \rtbl, \istart, \iend, #PMD_TYPE_TABLE, #PAGE_SIZE, \tmp
	mov \tbl, \sv
#endif

	compute_indices \vstart, \vend, #SWAPPER_BLOCK_SHIFT, #PTRS_PER_PTE, \istart, \iend, \count
	bic \count, \phys, #SWAPPER_BLOCK_SIZE - 1
	populate_entries \tbl, \count, \istart, \iend, \flags, #SWAPPER_BLOCK_SIZE, \tmp
	.endm

/*
 * Setup the initial page tables. We only setup the barest amount which is
 * required to get the kernel running. The following sections are required:
 *   - identity mapping to enable the MMU (low address, TTBR0)
 *   - first few MB of the kernel linear mapping to jump to once the MMU has
 *     been enabled
 */
SYM_FUNC_START_LOCAL(__create_page_tables)
	mov	x28, lr

	/*
	 * Invalidate the init page tables to avoid potential dirty cache lines
	 * being evicted. Other page tables are allocated in rodata as part of
	 * the kernel image, and thus are clean to the PoC per the boot
	 * protocol.
	 */
/* IAMROOT:
[arch/arm64/kernel/vmlinux.lds.S:304]
. = ALIGN(PAGE_SIZE);
init_pg_dir = .;
. += INIT_DIR_SIZE;
init_pg_end = .;
[arch/arm64/include/asm/kernel-pgtable.h:89]
#define INIT_DIR_SIZE (PAGE_SIZE * EARLY_PAGES(KIMAGE_VADDR, _end))
#define EARLY_PAGES(vstart, vend) ( 1 			/* PGDIR page 				\
			+ EARLY_PGDS((vstart), (vend)) 	/* each PGDIR needs a next level page table 	\
			+ EARLY_PUDS((vstart), (vend))	/* each PUD needs a next level page table 	\
			+ EARLY_PMDS((vstart), (vend)))	/* each PMD needs a next level page table 
#define EARLY_PGDS(vstart, vend) (EARLY_ENTRIES(vstart, vend, PGDIR_SHIFT))
#define EARLY_ENTRIES(vstart, vend, shift) \
	((((vend) - 1) >> (shift)) - ((vstart) >> (shift)) + 1 + EARLY_KASLR)
[arch/arm64/include/asm/pgtable-hwdef.h:69]
#define PGDIR_SHIFT		ARM64_HW_PGTABLE_LEVEL_SHIFT(4 - CONFIG_PGTABLE_LEVELS)

[.config]
CONFIG_PGTABLE_LEVELS=3

[arch/arm64/include/asm/pgtable-hwdef.h:41]
#define ARM64_HW_PGTABLE_LEVEL_SHIFT(n)	((PAGE_SHIFT - 3) * (4 - (n)) + 3)

#define SWAPPER_PGTABLE_LEVELS	(CONFIG_PGTABLE_LEVELS - 1) // 2
#if SWAPPER_PGTABLE_LEVELS > 3
#define EARLY_PUDS(vstart, vend) (EARLY_ENTRIES(vstart, vend, PUD_SHIFT))

#if SWAPPER_PGTABLE_LEVELS > 2
#define EARLY_PMDS(vstart, vend) (EARLY_ENTRIES(vstart, vend, SWAPPER_TABLE_SHIFT))

[System.map]
ffffffc008630000 B init_pg_dir
ffffffc008632000 B init_pg_end
 */
	adrp	x0, init_pg_dir
	adrp	x1, init_pg_end
	bl	dcache_inval_poc

/* IAMROOT: jake.dothome.co.kr/head-64-60/
[init_pg_dir = .;]
. += INIT_DIR_SIZE;
init_pg_end = .;
보안 향상을 위해 swapper 페이지 테이블을 read-only로 운영하기 위해 별도로 분리하고,
커널 초기 부팅 중에만 잠시 사용하기 위해 read-write 가능한 상태로 init 페이지 테이블을 운영한다
커널 영역(text, data, bss 섹션)에 한정하여 컴파일 타임에 계산

[swapper_pg_dir]
읽기 전용 커널 페이지 테이블, static으로 만들어지는 pgd 테이블을 제외하곤 필요시 동적으로 생성
 */
	/*
	 * Clear the init page tables.
	 */
	adrp	x0, init_pg_dir
	adrp	x1, init_pg_end
	sub	x1, x1, x0
1:	stp	xzr, xzr, [x0], #16
	stp	xzr, xzr, [x0], #16
	stp	xzr, xzr, [x0], #16
	stp	xzr, xzr, [x0], #16
	subs	x1, x1, #64
	b.ne	1b

/* IAMROOT:
#if ARM64_KERNEL_USES_PMD_MAPS
#define SWAPPER_MM_MMUFLAGS	(PMD_ATTRINDX(MT_NORMAL) | SWAPPER_PMD_FLAGS)
#ifdef CONFIG_ARM64_4K_PAGES
#define ARM64_KERNEL_USES_PMD_MAPS 1
#define SWAPPER_PMD_FLAGS	(PMD_TYPE_SECT | PMD_SECT_AF | PMD_SECT_S)
 */
	mov	x7, SWAPPER_MM_MMUFLAGS

/* IAMROOT:
[idmap_pg_dir] identity map page directory
MMU enable 시 가상 주소와 물리 주소가 1:1로 매핑되어 사용될 때 필요한 테이블로 영구적으로 사용
va == pa 이므로 __idmap_text_start를 pa, va 모두 같게 mapping
MMU를 켜기 위해서는 TTBR에 page table이 설정되어 있어야 한다.
Swapper page table을 사용하기 위한 중간 과정으로 idmap을 사용한다.
idmap을 통해 MMU를 켜면 D$를사용할 수 있음.

[arch/arm64/kernel/vmlinux.lds.S:88]
#define IDMAP_TEXT					\
	. = ALIGN(SZ_4K);				\
	__idmap_text_start = .;				\
	*(.idmap.text)					\
	__idmap_text_end = .;

	idmap_pg_dir = .;
	. += IDMAP_DIR_SIZE;
	idmap_pg_end = .;

[arch/arm64/include/asm/kernel-pgtable.h:90]
#define IDMAP_DIR_SIZE		(IDMAP_PGTABLE_LEVELS * PAGE_SIZE)
#if ARM64_KERNEL_USES_PMD_MAPS
#define IDMAP_PGTABLE_LEVELS	(ARM64_HW_PGTABLE_LEVELS(PHYS_MASK_SHIFT) - 1)

[System.map]
ffffffc0083d5000 T __idmap_text_start
ffffffc0083d58f4 T __idmap_text_end
ffffffc008496000 R idmap_pg_dir <-- __idmap_text_start
ffffffc008499000 T idmap_pg_end
ffffffc00853e158 D idmap_t0sz
ffffffc00853e160 D idmap_ptrs_per_pgd
ffffffc008630000 B init_pg_dir <-- KIMAGE_VADDR
ffffffc008632000 B init_pg_end
 */
	/*
	 * Create the identity mapping.
	 */
	adrp	x0, idmap_pg_dir
	adrp	x3, __idmap_text_start		// __pa(__idmap_text_start)

#ifdef CONFIG_ARM64_VA_BITS_52
	mrs_s	x6, SYS_ID_AA64MMFR2_EL1
	and	x6, x6, #(0xf << ID_AA64MMFR2_LVA_SHIFT)
	mov	x5, #52
	cbnz	x6, 1f
#endif
/* IAMROOT:
[.config]
CONFIG_ARM64_VA_BITS=39
[arch/arm64/include/asm/memory.h:43]
#define VA_BITS			(CONFIG_ARM64_VA_BITS)
#define VA_BITS_MIN		(VA_BITS)
 */
	mov	x5, #VA_BITS_MIN
/* IAMROOT: arch/arm64/mm/mmu.c:49
u64 __section(".mmuoff.data.write") vabits_actual;
EXPORT_SYMBOL(vabits_actual);
vabits_actual에 가상 주소 비트 수를 넣는다.
ID_MMFR2의 VARange 필드의 값에 따라 x5에 52 또는 39를 세팅한다.
해당 값은 VA의 bit 수를 의미한다.
 */
1:
	adr_l	x6, vabits_actual
	str	x5, [x6]
	dmb	sy
	dc	ivac, x6		// Invalidate potentially stale cache line

	/*
	 * VA_BITS may be too small to allow for an ID mapping to be created
	 * that covers system RAM if that is located sufficiently high in the
	 * physical address space. So for the ID map, use an extended virtual
	 * range in that case, and configure an additional translation level
	 * if needed.
	 *
	 * Calculate the maximum allowed value for TCR_EL1.T0SZ so that the
	 * entire ID map region can be mapped. As T0SZ == (64 - #bits used),
	 * this number conveniently equals the number of leading zeroes in
	 * the physical address of __idmap_text_end.
	 */
	adrp	x5, __idmap_text_end
	clz	x5, x5
/* IAMROOT: arch/arm64/include/asm/pgtable-hwdef.h:188
#define TCR_T0SZ_OFFSET		0
#define TCR_T1SZ_OFFSET		16
#define TCR_T0SZ(x)		((UL(64) - (x)) << TCR_T0SZ_OFFSET)
#define TCR_T1SZ(x)		((UL(64) - (x)) << TCR_T1SZ_OFFSET)
 */
	cmp	x5, TCR_T0SZ(VA_BITS_MIN) // default T0SZ small enough?
	b.ge	1f			// .. then skip VA range extension

/* IAMROOT: arch/arm64/mm/mmu.c:46
u64 idmap_t0sz = TCR_T0SZ(VA_BITS_MIN);
                 TCR_T0SZ(39) => 64 - 39 = 25
 */
	adr_l	x6, idmap_t0sz
	str	x5, [x6]
	dmb	sy
	dc	ivac, x6		// Invalidate potentially stale cache line

#if (VA_BITS < 48)
/* IAMROOT:
[.config]
CONFIG_PGTABLE_LEVELS=3
CONFIG_ARM64_PAGE_SHIFT=12
CONFIG_ARM64_PA_BITS=48

[arch/arm64/include/asm/pgtable-hwdef.h:69]
#define PGDIR_SHIFT		ARM64_HW_PGTABLE_LEVEL_SHIFT(4 - CONFIG_PGTABLE_LEVELS) // = 30 (4(MAX PGTABLE_LEVELS) - 3단계 PGTABLE_LEVELS)

[arch/arm64/include/asm/page-def.h:14]
#define PAGE_SHIFT		CONFIG_ARM64_PAGE_SHIFT

[arch/arm64/include/asm/pgtable-hwdef.h:41]
#define ARM64_HW_PGTABLE_LEVEL_SHIFT(n)	((PAGE_SHIFT - 3) * (4 - (n)) + 3) // (12-3)*(4-1)+3 = 30

[arch/arm64/include/asm/pgtable-hwdef.h:180]
#define PHYS_MASK_SHIFT		(CONFIG_ARM64_PA_BITS)

Translation table lookup with 4KB pages:
PGD -> PUD -> PMD -> PTE
+--------+--------+--------+--------+--------+--------+--------+--------+
|63    56|55    48|47    40|39    32|31    24|23    16|15     8|7      0|
+--------+--------+--------+--------+--------+--------+--------+--------+
 |                 |         |         |         |         |
 |                 |         |         |         |         v
 |                 |         |         |         |   [11:0]  in-page offset
 |                 |         |         |         +-> [20:12] L3 index (PTE)
 |                 |         |         +-----------> [29:21] L2 index (PMD)
 |                 |         +---------------------> [38:30] L1 index (PUD)
 |                 +-------------------------------> [47:39] L0 index (PGD/P4D)
 +-------------------------------------------------> [63] TTBR0/1
8byte로 adddress indexing 하므로 한 PAGE에서 indexing 할 수 있는 개수는
4096 byte / 8 byte = 512개 == (PAGE_SHIFT - 3)
VA_BITS 기본값은 39이고, PGTABLE_SHIFT는 30, PAGE_SHIFT는 12이다.
VA_BITS가 36이고 PAGE_SIZE가 4KB일 때, PGTABLE_LEVELS은 3단계 (9bit + 9bit + 9bit + 12bit)
PGD, PUD, PMD의 엔트리 개수는 각각 512개이므로 각 9비트의 크기가 인덱싱이 필요하다.
config PGTABLE_LEVELS
        default 3 if ARM64_4K_PAGES && ARM64_VA_BITS_39
 */
#define EXTRA_SHIFT	(PGDIR_SHIFT + PAGE_SHIFT - 3) // 30+12-3 = 39
#define EXTRA_PTRS	(1 << (PHYS_MASK_SHIFT - EXTRA_SHIFT)) // 1 << 48-39=9

	/*
	 * If VA_BITS < 48, we have to configure an additional table level.
	 * First, we have to verify our assumption that the current value of
	 * VA_BITS was chosen such that all translation levels are fully
	 * utilised, and that lowering T0SZ will always result in an additional
	 * translation level to be configured.
	 */
#if VA_BITS != EXTRA_SHIFT
#error "Mismatch between VA_BITS and page size/number of translation levels"
#endif

	mov	x4, EXTRA_PTRS
/* IAMROOT: Macro to create a table entry to the next page.
 *	x0, tbl:	page table address            == idmap_pg_dir
 *	x3, virt:	virtual address               == __idmap_text_start
 *	EXTRA_SHIFT, shift:	#imm page table shift == 39
 *	x4, ptrs:	#imm pointers per table page  == 2^(9) = 512
 * Returns:	tbl -> next level table page address
	.macro	create_table_entry, tbl, virt, shift, ptrs, tmp1, tmp2
 */
	create_table_entry x0, x3, EXTRA_SHIFT, x4, x5, x6
#else
	/*
	 * If VA_BITS == 48, we don't have to configure an additional
	 * translation level, but the top-level table has more entries.
	 */
	mov	x4, #1 << (PHYS_MASK_SHIFT - PGDIR_SHIFT)
	str_l	x4, idmap_ptrs_per_pgd, x5
#endif
1:
/* IAMROOT:
[arch/arm64/mm/mmu.c:47]
u64 idmap_ptrs_per_pgd = PTRS_PER_PGD;
[arch/arm64/include/asm/pgtable-hwdef.h:72]
#define PTRS_PER_PGD		(1 << (VA_BITS - PGDIR_SHIFT)) // 1 << (39 - 30) == 2^9 = 512
 */
	ldr_l	x4, idmap_ptrs_per_pgd
	adr_l	x6, __idmap_text_end		// __pa(__idmap_text_end)

/* IAMROOT:
map_memory, tbl, rtbl, vstart, vend, flags, phys, pgds, istart, iend, tmp, count, sv
map_memory x0(tbl), x1(rtbl), x3(vstart), x6(vend), x7(flags), x3(phys), x4(pgds), x10(istart), x11(iend), x12(tmp), x13(count), x14(sv)
map_memory x0(idmap_pg_dir), x1(rtbl), x3(__idmap_text_start), x6(__idmap_text_end), x7(SWAPPER_MM_MMUFLAGS), x3(phys), x4(idmap_ptrs_per_pgd), x10(istart), x11(iend), x12(tmp), x13(count), x14(sv)
 */
	map_memory x0, x1, x3, x6, x7, x3, x4, x10, x11, x12, x13, x14

	/*
	 * Map the kernel image (starting with PHYS_OFFSET).
	 */
	adrp	x0, init_pg_dir
	mov_q	x5, KIMAGE_VADDR		// compile time __va(_text)
	add	x5, x5, x23			// add KASLR displacement
	mov	x4, PTRS_PER_PGD
	adrp	x6, _end			// runtime __pa(_end)
	adrp	x3, _text			// runtime __pa(_text)
	sub	x6, x6, x3			// _end - _text
	add	x6, x6, x5			// runtime __va(_end)

/* IAMROOT:
map_memory x0(init_pg_dir), x1(rtbl), x5(KIMAGE_VADDR), x6(_end), x7(SWAPPER_MM_MMUFLAGS), x3(_text), x4(PTRS_PER_PGD), x10(istart), x11(iend), x12(tmp), x13(count), x14(sv)
 */
	map_memory x0, x1, x5, x6, x7, x3, x4, x10, x11, x12, x13, x14

	/*
	 * Since the page tables have been populated with non-cacheable
	 * accesses (MMU disabled), invalidate those tables again to
	 * remove any speculatively loaded cache lines.
	 */
	dmb	sy

	adrp	x0, idmap_pg_dir
	adrp	x1, idmap_pg_end
	bl	dcache_inval_poc

	adrp	x0, init_pg_dir
	adrp	x1, init_pg_end
	bl	dcache_inval_poc

	ret	x28
SYM_FUNC_END(__create_page_tables)

	/*
	 * Initialize CPU registers with task-specific and cpu-specific context.
	 *
	 * Create a final frame record at task_pt_regs(current)->stackframe, so
	 * that the unwinder can identify the final frame record of any task by
	 * its location in the task stack. We reserve the entire pt_regs space
	 * for consistency with user tasks and kthreads.
	 */
	.macro	init_cpu_task tsk, tmp1, tmp2
/* IAMROOT:
sp_el0는 유저 공간으로 context switch 된 후 유저용 스택 위치를 가리키는 용도로 사용된다.
그러나 커널(el1)에서는 사용하지 않는 스크래치 레지스터 용도일 뿐이므로 이를 활용하여
thread_info를 가리키는 레지스터로 사용
https://github.com/torvalds/linux/commit/6cdf9c7ca687e01840d0215437620a20263012fc
sp_el0는 유저에서 커널 모드 들어올 때 현재 태스크를 저장하고 커널 모드에서
현재 thread_info 를 빠르게 알아내는 용도로 사용되는데 사용된다.
커널모드에서 sp_el0는 스택과는 관련이 없다.
커널모드 스택은 sp 니모닉으로 바로 접근하며 이때 sp는 sp_el1이다.
sp_el0, sp_el1에 user, kernel에서 사용할 stack 주소를 넣어주고
spsel을 통해서 sp를 뭘쓸지 정해주면 sp가 자동으로 sp_el0, sp_el1에 설정했던 주소로 바꿈
*/
	msr	sp_el0, \tsk

	ldr	\tmp1, [\tsk, #TSK_STACK]     // TSK_STACK = 32 = offsetof(struct task_struct, stack)
	add	sp, \tmp1, #THREAD_SIZE       // THREAD_SIZE = 0x4000 (16KB)
	sub	sp, sp, #PT_REGS_SIZE         // PT_REGS_SIZE = 336 = sizeof(struct pt_regs)

	stp	xzr, xzr, [sp, #S_STACKFRAME] // S_STACKFRAME = offsetof(struct pt_regs, stackframe), u64 stackframe[2]
	add	x29, sp, #S_STACKFRAME

	scs_load \tsk                     // CONFIG_SHADOW_CALL_STACK - 함수반환주소 overflow를 방지하는 기능

	adr_l	\tmp1, __per_cpu_offset   // unsigned long __per_cpu_offset[NR_CPUS] [mm/percpu.c;3374]
	ldr	w\tmp2, [\tsk, #TSK_TI_CPU]   // TSK_TI_CPU = 16 = task_struct->thread_info.cpu
	ldr	\tmp1, [\tmp1, \tmp2, lsl #3]
	set_this_cpu_offset \tmp1         // 현재 cpu번호를 tpidr register에 저장
	.endm

/*
 * The following fragment of code is executed with the MMU enabled.
 *
 *   x0 = __PHYS_OFFSET
 */
SYM_FUNC_START_LOCAL(__primary_switched)
	adr_l	x4, init_task
	init_cpu_task x4, x5, x6

/* IAMROOT:
kernel용 vector table 주소 설정. vectors 위치 : kernel/entry.S
*/
	adr_l	x8, vectors			// load VBAR_EL1 with virtual
	msr	vbar_el1, x8			// vector table address
	isb

	stp	x29, x30, [sp, #-16]!
	mov	x29, sp

	str_l	x21, __fdt_pointer, x5		// Save FDT pointer

	ldr_l	x4, kimage_vaddr		// Save the offset between
	sub	x4, x4, x0			// the kernel virtual and
	str_l	x4, kimage_voffset, x5		// physical mappings

	// Clear BSS
	adr_l	x0, __bss_start
	mov	x1, xzr
	adr_l	x2, __bss_stop
	sub	x2, x2, x0
	bl	__pi_memset
	dsb	ishst				// Make zero page visible to PTW

#if defined(CONFIG_KASAN_GENERIC) || defined(CONFIG_KASAN_SW_TAGS)
	bl	kasan_early_init
#endif
	mov	x0, x21				// pass FDT address in x0
	bl	early_fdt_map			// Try mapping the FDT early
	bl	init_feature_override		// Parse cpu feature overrides
#ifdef CONFIG_RANDOMIZE_BASE
	tst	x23, ~(MIN_KIMG_ALIGN - 1)	// already running randomized?
	b.ne	0f
	bl	kaslr_early_init		// parse FDT for KASLR options
	cbz	x0, 0f				// KASLR disabled? just proceed
	orr	x23, x23, x0			// record KASLR offset
	ldp	x29, x30, [sp], #16		// we must enable KASLR, return
	ret					// to __primary_switch()
0:
#endif
	bl	switch_to_vhe			// Prefer VHE if possible
	ldp	x29, x30, [sp], #16
	bl	start_kernel
	ASM_BUG()
SYM_FUNC_END(__primary_switched)

	.pushsection ".rodata", "a"
SYM_DATA_START(kimage_vaddr)
	.quad		_text
SYM_DATA_END(kimage_vaddr)
EXPORT_SYMBOL(kimage_vaddr)
	.popsection

/*
 * end early head section, begin head code that is also used for
 * hotplug and needs to have the same protections as the text region
 */
	.section ".idmap.text","awx"

/*
 * Starting from EL2 or EL1, configure the CPU to execute at the highest
 * reachable EL supported by the kernel in a chosen default state. If dropping
 * from EL2 to EL1, configure EL2 before configuring EL1.
 *
 * Since we cannot always rely on ERET synchronizing writes to sysregs (e.g. if
 * SCTLR_ELx.EOS is clear), we place an ISB prior to ERET.
 *
 * Returns either BOOT_CPU_MODE_EL1 or BOOT_CPU_MODE_EL2 in w0 if
 * booted in EL1 or EL2 respectively.
 */
SYM_FUNC_START(init_kernel_el)
	mrs	x0, CurrentEL				// IAMROOT: MRS <Xt>, CurrentEL : EL, bits [3:2] 0b00 - EL0, 0b01 - EL1, 0b10 - EL2, 0x0b11 - EL3
	cmp	x0, #CurrentEL_EL2			// IAMROOT: arch/arm64/include/asm/ptrace.h:17 #define CurrentEL_EL2		(2 << 2)
	b.eq	init_el2

SYM_INNER_LABEL(init_el1, SYM_L_LOCAL)
	mov_q	x0, INIT_SCTLR_EL1_MMU_OFF	// IAMROOT: arch/arm64/include/asm/sysreg.h:683
	msr	sctlr_el1, x0					// IAMROOT: SCTLR_EL1 : System Control Register (EL1): MMU, Cache, alignment 검사 같은 아키텍쳐의 주요 기능을 제어
	isb
	mov_q	x0, INIT_PSTATE_EL1		// IAMROOT: rch/arm64/include/asm/ptrace.h:19
	msr	spsr_el1, x0
	msr	elr_el1, lr
	mov	w0, #BOOT_CPU_MODE_EL1		// IAMROOT: arch/arm64/include/asm/virt.h:49
	eret							// IAMROOT: exception return 하면서 SPSR_EL1 값이 PSTATE로 복원

SYM_INNER_LABEL(init_el2, SYM_L_LOCAL)
	mov_q	x0, HCR_HOST_NVHE_FLAGS
	msr	hcr_el2, x0
	isb

	init_el2_state

	/* Hypervisor stub */
	adr_l	x0, __hyp_stub_vectors
	msr	vbar_el2, x0
	isb

	/*
	 * Fruity CPUs seem to have HCR_EL2.E2H set to RES1,
	 * making it impossible to start in nVHE mode. Is that
	 * compliant with the architecture? Absolutely not!
	 */
	mrs	x0, hcr_el2
	and	x0, x0, #HCR_E2H
	cbz	x0, 1f

	/* Switching to VHE requires a sane SCTLR_EL1 as a start */
	mov_q	x0, INIT_SCTLR_EL1_MMU_OFF
	msr_s	SYS_SCTLR_EL12, x0

	/*
	 * Force an eret into a helper "function", and let it return
	 * to our original caller... This makes sure that we have
	 * initialised the basic PSTATE state.
	 */
	mov	x0, #INIT_PSTATE_EL2
	msr	spsr_el1, x0
	adr	x0, __cpu_stick_to_vhe
	msr	elr_el1, x0
	eret

1:
	mov_q	x0, INIT_SCTLR_EL1_MMU_OFF
	msr	sctlr_el1, x0

	msr	elr_el2, lr
	mov	w0, #BOOT_CPU_MODE_EL2
	eret

__cpu_stick_to_vhe:
	mov	x0, #HVC_VHE_RESTART
	hvc	#0
	mov	x0, #BOOT_CPU_MODE_EL2
	ret
SYM_FUNC_END(init_kernel_el)

/*
 * Sets the __boot_cpu_mode flag depending on the CPU boot mode passed
 * in w0. See arch/arm64/include/asm/virt.h for more info.
 */
SYM_FUNC_START_LOCAL(set_cpu_boot_mode_flag)
/* IAMROOT: arch/arm64/include/asm/virt.h:68
extern u32 __boot_cpu_mode[2];
아래에서 BOOT_CPU_MODE_EL2, BOOT_CPU_MODE_EL1로 초기화 되며
boot mode 확인하여 EL1 -> __boot_cpu_mode[0], EL2 -> __boot_cpu_mode[1]에 값을 써서 두 값을 동일하게 맞춤
 */
	adr_l	x1, __boot_cpu_mode
	cmp	w0, #BOOT_CPU_MODE_EL2
	b.ne	1f
	add	x1, x1, #4
1:	str	w0, [x1]			// Save CPU boot mode
	dmb	sy
	dc	ivac, x1			// Invalidate potentially stale cache line
	ret
SYM_FUNC_END(set_cpu_boot_mode_flag)

/*
 * These values are written with the MMU off, but read with the MMU on.
 * Writers will invalidate the corresponding address, discarding up to a
 * 'Cache Writeback Granule' (CWG) worth of data. The linker script ensures
 * sufficient alignment that the CWG doesn't overlap another section.
 */
	.pushsection ".mmuoff.data.write", "aw"
/*
 * We need to find out the CPU boot mode long after boot, so we need to
 * store it in a writable variable.
 *
 * This is not in .bss, because we set it sufficiently early that the boot-time
 * zeroing of .bss would clobber it.
 */
SYM_DATA_START(__boot_cpu_mode)
	.long	BOOT_CPU_MODE_EL2
	.long	BOOT_CPU_MODE_EL1
SYM_DATA_END(__boot_cpu_mode)
/*
 * The booting CPU updates the failed status @__early_cpu_boot_status,
 * with MMU turned off.
 */
SYM_DATA_START(__early_cpu_boot_status)
	.quad 	0
SYM_DATA_END(__early_cpu_boot_status)

	.popsection

	/*
	 * This provides a "holding pen" for platforms to hold all secondary
	 * cores are held until we're ready for them to initialise.
	 */
SYM_FUNC_START(secondary_holding_pen)
	bl	init_kernel_el			// w0=cpu_boot_mode
	bl	set_cpu_boot_mode_flag
	mrs	x0, mpidr_el1
	mov_q	x1, MPIDR_HWID_BITMASK
	and	x0, x0, x1
	adr_l	x3, secondary_holding_pen_release
pen:	ldr	x4, [x3]
	cmp	x4, x0
	b.eq	secondary_startup
	wfe
	b	pen
SYM_FUNC_END(secondary_holding_pen)

	/*
	 * Secondary entry point that jumps straight into the kernel. Only to
	 * be used where CPUs are brought online dynamically by the kernel.
	 */
SYM_FUNC_START(secondary_entry)
	bl	init_kernel_el			// w0=cpu_boot_mode
	bl	set_cpu_boot_mode_flag
	b	secondary_startup
SYM_FUNC_END(secondary_entry)

SYM_FUNC_START_LOCAL(secondary_startup)
	/*
	 * Common entry point for secondary CPUs.
	 */
	bl	switch_to_vhe
	bl	__cpu_secondary_check52bitva
	bl	__cpu_setup			// initialise processor
	adrp	x1, swapper_pg_dir
	bl	__enable_mmu
	ldr	x8, =__secondary_switched
	br	x8
SYM_FUNC_END(secondary_startup)

SYM_FUNC_START_LOCAL(__secondary_switched)
	adr_l	x5, vectors
	msr	vbar_el1, x5
	isb

	adr_l	x0, secondary_data
	ldr	x2, [x0, #CPU_BOOT_TASK]
	cbz	x2, __secondary_too_slow

	init_cpu_task x2, x1, x3

#ifdef CONFIG_ARM64_PTR_AUTH
	ptrauth_keys_init_cpu x2, x3, x4, x5
#endif

	bl	secondary_start_kernel
	ASM_BUG()
SYM_FUNC_END(__secondary_switched)

SYM_FUNC_START_LOCAL(__secondary_too_slow)
	wfe
	wfi
	b	__secondary_too_slow
SYM_FUNC_END(__secondary_too_slow)

/*
 * The booting CPU updates the failed status @__early_cpu_boot_status,
 * with MMU turned off.
 *
 * update_early_cpu_boot_status tmp, status
 *  - Corrupts tmp1, tmp2
 *  - Writes 'status' to __early_cpu_boot_status and makes sure
 *    it is committed to memory.
 */

	.macro	update_early_cpu_boot_status status, tmp1, tmp2
	mov	\tmp2, #\status
	adr_l	\tmp1, __early_cpu_boot_status
	str	\tmp2, [\tmp1]
	dmb	sy
	dc	ivac, \tmp1			// Invalidate potentially stale cache line
	.endm

/*
 * Enable the MMU.
 *
 *  x0  = SCTLR_EL1 value for turning on the MMU.
 *  x1  = TTBR1_EL1 value
 *
 * Returns to the caller via x30/lr. This requires the caller to be covered
 * by the .idmap.text section.
 *
 * Checks if the selected granule size is supported by the CPU.
 * If it isn't, park the CPU
 */
SYM_FUNC_START(__enable_mmu)
	mrs	x2, ID_AA64MMFR0_EL1                      // AArch64 Memory Model Feature Register 0
	ubfx	x2, x2, #ID_AA64MMFR0_TGRAN_SHIFT, 4  // == 28, TGran4, bits [31;28] Indicates support for 4KB memory translation granule size.
	cmp     x2, #ID_AA64MMFR0_TGRAN_SUPPORTED_MIN // == 0, 4KB granule supported
	b.lt    __no_granule_support
	cmp     x2, #ID_AA64MMFR0_TGRAN_SUPPORTED_MAX // == 7, 4KB granule not supported
	b.gt    __no_granule_support
	update_early_cpu_boot_status 0, x2, x3        // __early_cpu_boot_status 에 저장, 최신 버전에서는 삭제됨
/* IAMROOT:
 * ttbr0_el1 : user용이지만 부팅중에는 임시로 idmap으로 사용한다.
 * ttbr1_el1 : kernel용이며 init_pg_dir을 가리킨다.
 */
	adrp	x2, idmap_pg_dir
	phys_to_ttbr x1, x1
	phys_to_ttbr x2, x2
	msr	ttbr0_el1, x2			// load TTBR0, x2 = idmap_pg_dir
	offset_ttbr1 x1, x3
	msr	ttbr1_el1, x1			// load TTBR1, x1 = init_pg_dir
	isb

	set_sctlr_el1	x0          // mov_q	x0, INIT_SCTLR_EL1_MMU_ON

	ret
SYM_FUNC_END(__enable_mmu)

SYM_FUNC_START(__cpu_secondary_check52bitva)
#ifdef CONFIG_ARM64_VA_BITS_52
	ldr_l	x0, vabits_actual
	cmp	x0, #52
	b.ne	2f

	mrs_s	x0, SYS_ID_AA64MMFR2_EL1
	and	x0, x0, #(0xf << ID_AA64MMFR2_LVA_SHIFT)
	cbnz	x0, 2f

	update_early_cpu_boot_status \
		CPU_STUCK_IN_KERNEL | CPU_STUCK_REASON_52_BIT_VA, x0, x1
1:	wfe
	wfi
	b	1b

#endif
2:	ret
SYM_FUNC_END(__cpu_secondary_check52bitva)

/* IAMROOT:
arch/arm64/include/asm/smp.h:19
The cpu couldn't die gracefully and is looping in the kernel
#define CPU_STUCK_IN_KERNEL		(2)
#define CPU_STUCK_REASON_NO_GRAN	(UL(2) << CPU_STUCK_REASON_SHIFT)
__early_cpu_boot_status에 저장
*/
SYM_FUNC_START_LOCAL(__no_granule_support)
	/* Indicate that this CPU can't boot and is stuck in the kernel */
	update_early_cpu_boot_status \
		CPU_STUCK_IN_KERNEL | CPU_STUCK_REASON_NO_GRAN, x1, x2
1:
	wfe
	wfi
	b	1b
SYM_FUNC_END(__no_granule_support)

#ifdef CONFIG_RELOCATABLE
SYM_FUNC_START_LOCAL(__relocate_kernel)
	/*
	 * Iterate over each entry in the relocation table, and apply the
	 * relocations in place.
	 */
/* IAMROOT:
arch/arm64/kernel/vmlinux.lds.S:259
	.rela.dyn : ALIGN(8) {
		*(.rela .rela*)
	}
	__rela_offset	= ABSOLUTE(ADDR(.rela.dyn) - KIMAGE_VADDR);
	__rela_size	= SIZEOF(.rela.dyn);
x23 : compile time에 계산된 kernel 주소의 2MB 정렬의 나머지값.
relocate start address(x9) = x23(0) + KIMAGE_VADDR(x11) + __rela_offset(w9)
relocate end address(x10) = x9 + __rela_size(w10)
*/
	ldr	w9, =__rela_offset		// offset to reloc table
	ldr	w10, =__rela_size		// size of reloc table

	mov_q	x11, KIMAGE_VADDR		// default virtual offset
	add	x11, x11, x23			// actual virtual offset
	add	x9, x9, x11			// __va(.rela)
	add	x10, x9, x10			// __va(.rela) + sizeof(.rela)

/* IAMROOT:
elf 스펙상 현재 Table Entry를 24byte씩 사용한다.
 *  x12 = [x9];
 *  x13 = [x9, 8];
 *  x9 += 24;
 *  x14 = [x9 - 8];
*/
0:	cmp	x9, x10
	b.hs	1f                   // if(x9 > x10) goto 1f
	ldp	x12, x13, [x9], #24      // [x9] 주소에서 24 bytes 적재
	ldr	x14, [x9, #-8]           // x12(offset) | x13(info{type}) | x14(addend)
	cmp	w13, #R_AARCH64_RELATIVE // if (type == R_AARCH64_RELATIVE(0x403))
	b.ne	0b
	add	x14, x14, x23			// relocate
	str	x14, [x12, x23]
	b	0b

1:
#ifdef CONFIG_RELR
	/*
	 * Apply RELR relocations.
	 *
	 * RELR is a compressed format for storing relative relocations. The
	 * encoded sequence of entries looks like:
	 * [ AAAAAAAA BBBBBBB1 BBBBBBB1 ... AAAAAAAA BBBBBB1 ... ]
	 *
	 * i.e. start with an address, followed by any number of bitmaps. The
	 * address entry encodes 1 relocation. The subsequent bitmap entries
	 * encode up to 63 relocations each, at subsequent offsets following
	 * the last address entry.
	 *
	 * The bitmap entries must have 1 in the least significant bit. The
	 * assumption here is that an address cannot have 1 in lsb. Odd
	 * addresses are not supported. Any odd addresses are stored in the RELA
	 * section, which is handled above.
	 *
	 * Excluding the least significant bit in the bitmap, each non-zero
	 * bit in the bitmap represents a relocation to be applied to
	 * a corresponding machine word that follows the base address
	 * word. The second least significant bit represents the machine
	 * word immediately following the initial address, and each bit
	 * that follows represents the next word, in linear order. As such,
	 * a single bitmap can encode up to 63 relocations in a 64-bit object.
	 *
	 * In this implementation we store the address of the next RELR table
	 * entry in x9, the address being relocated by the current address or
	 * bitmap entry in x13 and the address being relocated by the current
	 * bit in x14.
	 *
	 * Because addends are stored in place in the binary, RELR relocations
	 * cannot be applied idempotently. We use x24 to keep track of the
	 * currently applied displacement so that we can correctly relocate if
	 * __relocate_kernel is called twice with non-zero displacements (i.e.
	 * if there is both a physical misalignment and a KASLR displacement).
	 */
	ldr	w9, =__relr_offset		// offset to reloc table
	ldr	w10, =__relr_size		// size of reloc table
	add	x9, x9, x11			// __va(.relr)
	add	x10, x9, x10			// __va(.relr) + sizeof(.relr)

	sub	x15, x23, x24			// delta from previous offset
	cbz	x15, 7f				// nothing to do if unchanged
	mov	x24, x23			// save new offset

2:	cmp	x9, x10
	b.hs	7f
	ldr	x11, [x9], #8
	tbnz	x11, #0, 3f			// branch to handle bitmaps
	add	x13, x11, x23
	ldr	x12, [x13]			// relocate address entry
	add	x12, x12, x15
	str	x12, [x13], #8			// adjust to start of bitmap
	b	2b

3:	mov	x14, x13
4:	lsr	x11, x11, #1
	cbz	x11, 6f
	tbz	x11, #0, 5f			// skip bit if not set
	ldr	x12, [x14]			// relocate bit
	add	x12, x12, x15
	str	x12, [x14]

5:	add	x14, x14, #8			// move to next bit's address
	b	4b

6:	/*
	 * Move to the next bitmap's address. 8 is the word size, and 63 is the
	 * number of significant bits in a bitmap entry.
	 */
	add	x13, x13, #(8 * 63)
	b	2b

7:
#endif
	ret

SYM_FUNC_END(__relocate_kernel)
#endif

SYM_FUNC_START_LOCAL(__primary_switch)
#ifdef CONFIG_RANDOMIZE_BASE
	mov	x19, x0				// preserve new SCTLR_EL1 value
	mrs	x20, sctlr_el1			// preserve old SCTLR_EL1 value
#endif

	adrp	x1, init_pg_dir
	bl	__enable_mmu
#ifdef CONFIG_RELOCATABLE
#ifdef CONFIG_RELR
	mov	x24, #0				// no RELR displacement yet
#endif
	bl	__relocate_kernel   // 이 함수를 수행해야 .rela.dyn에서 ""=__primary_switched"를 채워줌
#ifdef CONFIG_RANDOMIZE_BASE
	ldr	x8, =__primary_switched // 현재 TTBR0에서 TTBR1의 __primary_switched 주소를 접근하기 위하여 ldr 사용
	adrp	x0, __PHYS_OFFSET
	blr	x8

	/*
	 * If we return here, we have a KASLR displacement in x23 which we need
	 * to take into account by discarding the current kernel mapping and
	 * creating a new one.
	 */
	pre_disable_mmu_workaround
	msr	sctlr_el1, x20			// disable the MMU
	isb
	bl	__create_page_tables		// recreate kernel mapping

	tlbi	vmalle1				// Remove any stale TLB entries
	dsb	nsh
	isb

	set_sctlr_el1	x19			// re-enable the MMU

	bl	__relocate_kernel
#endif
#endif
	ldr	x8, =__primary_switched  // x8 == 0xffffffc0084a02a4
	adrp	x0, __PHYS_OFFSET    // __PHYS_OFFSET == 0x40200000 
	br	x8
SYM_FUNC_END(__primary_switch)
